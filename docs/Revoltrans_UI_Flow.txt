Hierarchical Step-by-step UI Flow Outline — Revoltrans(First draft — covers Public, Customer, Vendor, Driver, Admin roles; includes mobile/web differences, API interaction points, error & retry flows, deep links and external integrations.)Legend / conventions* [API ? path] — indicates a backend call (endpoint shown).* (mobile-only) or (web-only) — platform-specific notes.* Error / Retry — explicit failure handling or retry path.* Deep link — screen accessible via direct URL or mobile intent (e.g. app://journeys/{id}).Top-level notes (source)This outline is built from your process flow and project docs, plus the Swagger API file you uploaded. Key references include the process flow overview and the API definitions such as registration/verify, waybills and admin endpoints. 1) PUBLIC / UNAUTHENTICATED FLOWS (Onboarding & Entry)A. Landing / Marketing page (web)1. Screen: Landing with CTA: Sign up / Login / Learn more.2. Action: user taps Sign up ? pushed to Registration screen (web route /signup).3. Deep links: /signup, /login, /help.B. Registration screen (mobile & web)1. Inputs: username, full_name, email, phone_number, password, user_type (CLIENT/VENDOR/DRIVER/ADMIN).2. On submit ? API: POST /api/v1/auth/register. (returns user_id + "verification code sent" message). 3. UI transition: show Verify Phone screen (enter 5-digit code). (mobile: optionally offer auto-read SMS where platform permits).4. Error states:o 400 / validation ? show inline field errors (highlight field + message).o 409 / duplicate ? show "email/username already exists" modal with link to Login.5. Retry / UX: show "Resend code" button (calls Re-send endpoint) and a countdown timer to prevent abuse.C. Verify Phone / Code entry1. Inputs: user_id, code (5 digits).2. API: POST /api/v1/auth/verify ? on success returns access_token + refresh_token + user object. 3. On success: proceed to Profile Completion (role-specific) or direct to Dashboard if profile already complete.4. Error states:o 400 / invalid code ? inline error + "Try again" and option to resend code.o 429 / rate limit (if too many resend attempts) ? show rate-limit message and delay UI resend. D. Login screen (mobile & web)1. Inputs: email or username, password.2. API: POST /api/v1/auth/login (or /api/v1/auth/login equivalent in swagger) ? returns access_token, refresh_token, user. 3. Success: route to role-specific dashboard.4. Errors:o 401 / bad creds ? inline message + "Forgot password" CTA.o Account unverified ? show action to resend verification and link to Verify screen.5. Token lifecycle: include logic to call POST /api/v1/auth/refresh when access token expires. 2) CUSTOMER (Client) FLOWS — core user journeyA. Customer Onboarding / Profile Completion1. After verify/login: show Profile Completion (address, preferred payment methods). API: profile completion endpoint (swagger: profile routes). 2. (mobile: ask permission for push notifications / location).B. Create Transport Request (main happy path)1. Screen: Create Request form — origin, destination, transport_type (truck/car), date/time, special instructions, pickup contact.2. UX elements: autosuggest origin/destination (integrate maps), date/time picker, transport type radio buttons.3. API: POST /api/v1/journeys/create ? returns journey_id. (display success toast + link to Journey Details). 4. After create: show Journey Request Submitted screen with ETA to vendor assignment. (deep link: /journeys/{id})C. Journey Tracking & Status updates (real-time)1. Customer can view Journey Details screen (route, assigned vendor, driver, status timeline, ETA). API: GET /api/v1/journeys/{id}. 2. Real-time updates: via webhooks / polling / WebSocket (implementation note from process flow). Show “last updated at” + spinner while waiting for driver assignment. 3. Errors: if location or real-time feed fails ? show stale data notice and fallback to manual refresh.D. Journey Completion & Payment1. Once driver marks completed, customer sees Review & Pay screen.2. API: POST /api/v1/payments/request (journey_id, amount, reason) to create payment request (vendor/driver flow) and GET /api/v1/payments/{id} to track payment status. 3. UI: show payment modal, success confirmation, and journey closed state on success.4. Error/Retry:o Payment failure ? show retry, alternative payment methods, and support contact.o Network/timeouts ? display offline confirmation + queue retry (mobile) or ask user to retry manually (web).E. Journey History & Analytics1. Screen: History (paginated table/cards). API: admin/clients or journeys listing endpoints. (Filters: date, status). 2. UX: search, filters, export (CSV). Deep-linkable to /history, /journeys/{id}.3) VENDOR FLOWSA. Vendor Onboarding & Registration1. Vendor registers with business details (company name, tax ID, registration docs). API: POST /api/v1/auth/register with user_type=VENDOR then profile completion APIs. 2. Admin approval required (vendor stays in PENDING state). Vendor sees "Awaiting approval" screen. Admin approval endpoints described in admin API. B. Transport Request Management (Vendor dashboard)1. Screen: Requests List — new requests, assigned, in-progress, completed. (List view + action buttons: Accept / Reject / Assign driver).2. Accepting a request triggers backend action; API (example): PUT /api/v1/journeys/{id}/assign or vendor-specific accept endpoint — map to swagger approvals / journeys. (Use the journeys API for details.) 3. Error states: concurrency checks (job already assigned), show conflict message and refresh list.C. Assign Driver1. UI: modal to choose driver from vendor's driver list. API: vendor assignment endpoint (backend). Show confirmation modal, then notify driver (in-app / SMS).2. Deep link to assignment: /vendor/requests/{id}.D. Upload Waybill Documentation (critical)1. Screen: Upload Waybill (drag & drop or choose file). (Mobile: camera capture).2. API: POST /api/v1/waybills (multipart/form-data) — file, journey_id, optional waybill_number. Success returns Waybill object (url on S3). 3. Follow-up: GET /api/v1/waybills/{waybill_id} or download. Download endpoint: GET /api/v1/waybills/{waybill_id}/download (binary). 4. Errors & retries:o 400 / no file ? show inline error.o 422 / invalid format or too large ? show accepted formats + limit. o Upload retries: implement client-side retry + progress indicator; fallback to chunked uploads if needed.E. Vendor Analytics Dashboard1. Charts for completed journeys, revenue, pending payments — data from admin/dashboard analytics endpoints. 4) DRIVER FLOWSA. Driver Onboarding & Verification1. Driver fills personal info and uploads driver license / vehicle docs. API: profile completion endpoint (role-specific). Onboarding requires admin verification. 2. Driver sees approval status via GET /api/v1/auth/driver-approval-status (PENDING/APPROVED/REJECTED). B. Receiving Assignments1. Screen: Assigned Journeys list (push notifications for new assignments on mobile).2. Driver can Accept / Decline — updates sent to journeys API (e.g., PUT /api/v1/journeys/{id}/update-status with status transitions). C. Journey Status Updates & Delivery Documentation1. Screen: Update Status (started / in-progress / completed) + attach proof (photos, signatures, waybills).2. API: PUT /api/v1/journeys/{id}/update-status. For documents: POST /api/v1/waybills (driver upload path).3. Errors: if upload fails, allow retry + local caching until network available (mobile).D. Expense Requests & Payment Confirmation1. Driver submits expense request (fuel, dispatch) via POST /api/v1/payments/request or vendor/driver-specific payment-request endpoints. Admin approves or rejects via admin payment APIs.5) ADMIN / SUPER-ADMIN FLOWS (Hierarchical cluster)A. Admin Login & Dashboard1. Admin signs in (same auth endpoints) and lands on Admin Dashboard (summary metrics). API: GET /api/v1/admin/dashboard/summary and other analytics endpoints. B. Approvals (drivers / vendors / payments)1. Screen: Approvals List (drivers/vendors/payment-requests) with filters and bulk action support.2. APIs:o Drivers approvals list: GET /api/v1/admin/approvals/drivers and update PUT /api/v1/admin/approvals/drivers/{driver_id}. o Vendor approvals: GET /api/v1/admin/approvals/vendors and PUT /api/v1/admin/approvals/vendors/{vendor_id}. o Payment approvals: GET /api/v1/admin/approvals/payment-requests and PUT /api/v1/admin/approvals/payment-requests/{request_id}. 3. Error / retry flows:o 404 / resource not found ? show appropriate message and refresh.o 403 / insufficient permissions ? show permission error and reason.C. User Management, Roles & Permissions1. Screen: Admin Users & Roles — list, create, update roles. APIs: GET/POST /api/v1/admin/admins, PUT /api/v1/admin/admins/{id}/roles, GET /api/v1/admin/roles. D. Document Verification & Waybill Management1. Admin verifies waybills: POST /api/v1/waybills/{waybill_id}/verify (accessible to clients/vendors/admins). Admin can download original via /download.6) Cross-cutting flows, error handling & retry strategiesA. Token & session management* Access token on login/verify; use POST /api/v1/auth/refresh to refresh tokens. Implement automatic refresh and safe logout on refresh failure. B. Network / API errors (general)* 400/422: show field-level validation.* 401: redirect to Login (clear local tokens).* 403: show permission denied (admin-only message with contact).* 429: rate-limit messages (for resend code, etc.) — show cooldown timer. * 500: show friendly "Something went wrong" with retry action and telemetry/error logging option.C. Retry UX patterns* Idempotent GETs — safe to retry on failures.* POSTs (create) — show a "processing" state, disable duplicate submissions; backend should support idempotency keys where appropriate.* Uploads — show progress bar, allow resume or background retry (especially mobile). 7) Deep links & external integrations (where to show them)Deep links* /journeys/{id} — open specific journey (customer/vendor/driver/admin variants).* /waybills/{id}/download — direct binary download (requires auth token). External integrations (explicit)* AWS S3 — waybill storage & URLs returned by POST /api/v1/waybills. (frontend uses signed URL or backend serving). * Mapping / Route optimization — autosuggest addresses, route preview, ETA calculations (integrate Google Maps / Mapbox as needed). * SMS provider — for verification codes and notifications (backend sends code; frontend shows entry and resend paths). * Payment Gateway(s) — external payment provider integration for payout/disbursement and recurring payments (triggered by payment endpoints). 8) Minimal screen map (hierarchical snapshot)(Use this as the diagram blueprint — grouped per role)Public* Landing ? Register ? Verify ? Login / Forgot passwordCustomer (shared mobile/web)* Dashboard ? Create Request ? Request Submitted ? Journey Detail (/journeys/{id}) ? Review & Pay ? HistoryVendor (shared / admin-only parts in web)* Vendor Dashboard ? Requests List ? Request Detail ? Assign Driver ? Upload Waybill (POST /api/v1/waybills) ? Close Journey ? AnalyticsDriver (mobile-first)* Driver Dashboard ? Assigned Journeys ? Journey Detail ? Update Status ? Upload Proof ? Confirm PaymentAdmin (web-focused)* Admin Dashboard ? Approvals (vendors/drivers/payments) ? User Management ? Roles/Permissions ? Financial & Journey Analytics(Each arrow above includes API calls documented earlier — see sections and Swagger snippets.) 